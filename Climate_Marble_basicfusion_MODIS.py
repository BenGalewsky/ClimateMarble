"""
Created on Wed Sep 11 12:35:35 2019

@author: yizhe

Climate Marble@BasicFusion

This code is based on the previous MODIS climate marble scripts, but working directly on the basic fusion (BF) files.
BF files contain radiances, sun-view geometry and geolocations for all five instruments onboard EOS-Terra. It stores these information by granule.
For each day, the general workflow is:
    1) initialize result arrays - orbit_insolation_sum, orbit_radiance_sum, orbit_radiance_num;
    2) call fetch_bf_files(iyr, imon, iday) to get the BF file list;
    For each BF file:
        (2.1 read MODIS radiance and the corresponding lat/lon, vza/sza;
        (2.2 radiance quality control;
        (2.3 calculate spectral band insolation by cos(sza)*rad_scale/ref_scale
        (2.4 call sort() to sort discrete MODIS samples into specified grids;
    3) call save_data_hdf5() to save result arrays.


Modified on Oct 10, 2019

Considering the BF files are staged in the monthly manner on AWS cloud, the script is then modified to process and save results for each orbit 
instead of a day.
"""

import numpy as np
import os
import sys
import h5py
import xarray as xr
from Climate_Marble_common_functions import latslons_to_idxs, get_descending
from sample2grid_sw import sort



def main_bf_MODIS(bf_h5f, output_folder, SPATIAL_RESOLUTION=0.5, VZA_MAX=18, CATEGORY='VIS'):
    """
    An updated function of main_daily, adapted working on the basic fusion files on AWS cloud.
    The MODIS gridded file for each orbit will be generated directly from the basic fusion data files.
    
    Args:
        bf_file (str)                       : BF file path
        output_folder (str)                 : folder storing the gridded results
        SPATIAL_RESOLUTION (float, optional): spatial resolution of the grid (in degree)
        VZA_MAX (int, optional)             : maximum viewing zenith angle considered (in degree
        CATEGORY (str, optional)            : category of MODIS radiances ('VIS', 'SWIR', or 'LW')
    
    Returns:
        there is no return value for this function
    """

    # =============================================================================
    # 1. Initialization
    #    calculate constant parameters
    #    initialize output arrays and output hdf5 file (LW does not use orbit_insolation_sum)
    #    fetch basic fusion files
    #    check the number of MODIS granules 
    # =============================================================================
    output_nc_name = bf_file.split('/')[-1].replace('TERRA_BF_L1B', 'CLIMARBLE')
    output_nc_name = output_nc_name.replace('.h5', '.nc')

    # 
    NUM_POINTS = 1 / SPATIAL_RESOLUTION
    NUM_LATS = int(180 / SPATIAL_RESOLUTION)
    NUM_LONS = int(360 / SPATIAL_RESOLUTION)
    if CATEGORY == 'VIS':
        NUM_CHAN = 7
    elif CATEGORY == 'SWIR':
        NUM_CHAN = 15
    elif CATEGORY == 'LW':
        NUM_CHAN = 16
    
    # 
    orbit_radiance_sum = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN))
    orbit_radiance_num = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN), dtype='int16')
    orbit_insolation_sum = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN))
    orbit_nc_out = os.path.join(output_folder, output_nc_name)


    # =============================================================================
    # 2. Main processing
    #    Loop through each MODIS granule and sort the radiances into the corresponding lat/lon bins.
    #    Times are generated by reading the available items in the daily dataset.
    #    When encounters a missing granule, script will raise a KeyError and move to the next granule.
    # =============================================================================
    try:
        h5f = h5py.File(bf_file, 'r')
    except IOError:
        print (">> IOError( cannot access BF file {}, ignore this orbit )".format(bf_file))
        return
    
    # USE MODIS granules to find all descending granules
    MODIS_granules = get_descending(h5f, 'MODIS')
    if MODIS_granules[0] == 0:
        print (">> IOError( no available MODIS granule in orbit {} )".format(bf_file))
        return

    for igranule in MODIS_granules:     
        # =============================================================================
        # 2.1 MOD03 check
        #     lat/lon check
        #     lats, lons, lats_idx, lons_idx will be used in the main fortran subroutine
        # =============================================================================
        try:
            lats = h5f['MODIS/{}/_1KM/Geolocation/Latitude'.format(igranule)][:]
            lons = h5f['MODIS/{}/_1KM/Geolocation/Longitude'.format(igranule)][:]
        except KeyError:
            print (">> KeyError( cannot access lat/lon in {} )".format(igranule))
            continue

        # Calculate lat/lon indexes of all sample. 
        # (2018.05.29) Explicitly convert these indexes to integer
        lats_idx, lons_idx = latslons_to_idxs(lats, lons, NUM_POINTS)

        # SZA/VZA check is applied here. 
        # sza, vza, valid_y, valid_x, valid_num will be used in the main fortran subroutine
        try:
            sza = h5f['MODIS/{}/SolarZenith'.format(igranule)][:, :]
            vza = h5f['MODIS/{}/SensorZenith'.format(igranule)][:, :]
        except KeyError:
            print (">> KeyError( cannot access sza/vza in {} )".format(igranule))
            continue
        cosine_sza = np.cos(np.deg2rad(sza))
    
        # SAMPLE-LEVEL CHECK is applied here
        # 0 <= SZA <= 89.0  and  0 <= VZA < 40.0 and longitude_indexes >= 0     
        # Get valid_num, valid_x, valid_y
        valid_y, valid_x = np.where((sza>=0)&(sza<=89.0)&(vza>=0)&(vza<VZA_MAX)&(lons_idx>=0))
        valid_num = len(valid_x)
        if valid_num == 0:
            print (">> CriteriaError( no valid samples in granule {} )".format(igranule))
            continue

        # =============================================================================
        # 2.2 MOD02 radiance check
        # Since most (not all) bands' (1--7) 65528 suggest saturation, Larry and I decided
        # to replace all 65528 values with spectral maximum radiance.
        #
        # Because 65528 is actually Aggregation Algorithm Failure that not only caused by
        # the signal saturation, red band is used to determine whether the sample is actually
        # saturated (red_band != 65528) or is caused by any other issues (red_band == 65528).
        #
        # Note that:
        # 1) Saturated samples in other bands are refilled only when red_band != 65528.
        # 2) Red band samples are never refilled.
        # 3) This approach is only applied to VIS category (not for SWIR and LW categories).
        # =============================================================================
        mdata = []
        rad_scales = []
        ref_scales = []

        if CATEGORY == 'VIS':
            for ifld in ['EV_250_Aggr1km_RefSB', 'EV_500_Aggr1km_RefSB']:
                sds = h5f['MODIS/{}/_1KM/Data_Fields/{}'.format(igranule, ifld)]
                for iband in range(len(sds)):
                    mdata.append(sds[iband])
                    rad_scales.append(sds.attrs['radiance_scales'][iband])
                    ref_scales.append(sds.attrs['reflectance_scales'][iband])

        # elif CATEGORY == 'SWIR':
        #     sds = h4f.select('EV_1KM_RefSB')
        #     data_int = sds.get()
        #     for iband in range(len(data_int)):
        #         mdata.append(data_int[iband])
        #         rad_scales.append(sds.attributes()['radiance_scales'][iband])
        #         rad_offsets.append(sds.attributes()['radiance_offsets'][iband])
        #         ref_scales.append(sds.attributes()['reflectance_scales'][iband])
        #         ref_offsets.append(sds.attributes()['reflectance_offsets'][iband])

        # elif CATEGORY == 'LW':
        #     sds = h4f.select('EV_1KM_Emissive')
        #     data_int = sds.get()
        #     for iband in range(len(data_int)):
        #         mdata.append(data_int[iband])
        #         rad_scales.append(sds.attributes()['radiance_scales'][iband])
        #         rad_offsets.append(sds.attributes()['radiance_offsets'][iband])

        # convert data into numpy arrays
        mdata = np.array(mdata)
        rad_scales = np.array(rad_scales)
        ref_scales = np.array(ref_scales)

        # calculate coefficients
        if CATEGORY in ['VIS', 'SWIR']:
            coeffs = rad_scales / ref_scales
        elif CATEGORY == 'LW':
            coeffs = [0.]*16

        # spectral radiances have been calculated, so we just use it.
        # for insolation = cos(sza) * rad_scale / ref_scale
        # for reflected_radiance_max = (32767 - rad_offset) * rad_scale
        sols = []
        rads = []
        rads_max = []
        for iband in range(NUM_CHAN):
            tmp_sol = cosine_sza * coeffs[iband]

            tmp_rad = mdata[iband]
            tmp_rad_max = 32767 * rad_scales[iband]
            
            # Refill only applied to VIS category
            if (CATEGORY == 'VIS') & (iband > 0):
                refill_mask = (mdata[0] > 0) & (tmp_rad == -992)
                num_saturated_samples = len(np.where(refill_mask.ravel()==True)[0])
                if num_saturated_samples > 0:
                    # print ">> Warning, band {} has {} saturated samples".format(iband+1, num_saturated_samples)
                    np.place(tmp_rad, refill_mask, tmp_rad_max)

            sols.append( tmp_sol )
            rads.append( tmp_rad )
            rads_max.append( tmp_rad_max )
        
        
        sols = np.array(sols)
        rads = np.array(rads)
        sols = np.rollaxis(sols, 0, 3)
        rads = np.rollaxis(rads, 0, 3)
        rads_max = np.array(rads_max)

        # =============================================================================
        # 2.3 Call main fortran subroutine to sort granule samples into lat/lon grids
        #
        # Get orbit_insolation_sum, orbit_radiance_sum, orbit_radiance_num
        # valid lat/lon   (lat != -999 and lon != -999 and idx_lat/lon are valid)
        # valid radiance  (0 < rad <= rad_max)
        # =============================================================================
        try:
            orbit_insolation_sum, orbit_radiance_sum, orbit_radiance_num = sort(NUM_CHAN, NUM_LATS, NUM_LONS, \
                valid_num, valid_x, valid_y, \
                len(lats_idx), lats, lons, lats_idx, lons_idx, \
                rads, sols, rads_max, \
                orbit_insolation_sum, orbit_radiance_sum, orbit_radiance_num)
        except Exception as e:
            print (">> FunctionError( fortran code went wrong in {}: {} )".format(itime, e))
            continue

    # =============================================================================
    # 3. Close basicfusion file
    # =============================================================================
    h5f.close()
    
    # =============================================================================
    # 4. Save output arrays
    # =============================================================================
    coords_lats = np.linspace(90-SPATIAL_RESOLUTION/2, -90+SPATIAL_RESOLUTION/2, NUM_LATS)
    coords_lons = np.linspace(-180+SPATIAL_RESOLUTION/2, 180-SPATIAL_RESOLUTION/2, NUM_LONS)

    xr_sw_sum = xr.DataArray(orbit_radiance_sum, coords=[('latitude', coords_lats), ('longitude', coords_lons), ('modis_channel', range(NUM_CHAN))])
    xr_sw_num = xr.DataArray(orbit_radiance_num, coords=[('latitude', coords_lats), ('longitude', coords_lons), ('modis_channel', range(NUM_CHAN))])
    xr_sw_sum.encoding['_FillValue'] = 0
    xr_sw_num.encoding['_FillValue'] = 0
    xr_sw_sum.name = 'MODIS spec rad sum'
    xr_sw_num.name = 'MODIS spec rad num'
    xr_sw_sum.to_netcdf(orbit_nc_out, 'w')
    xr_sw_num.to_netcdf(orbit_nc_out, 'a')

    if CATEGORY in ['VIS', 'SWIR']:
        xr_sol_sum = xr.DataArray(orbit_insolation_sum, coords=[('latitude', coords_lats), ('longitude', coords_lons), ('modis_channel', range(NUM_CHAN))])
        xr_sol_sum.encoding['_FillValue'] = 0
        xr_sol_sum.name = 'MODIS spec insol sum'
        xr_sol_sum.to_netcdf(orbit_nc_out, 'a')

    return orbit_nc_out


if __name__ == "__main__":
    bf_file = sys.argv[1]
    main_bf_MODIS(bf_file, '')







